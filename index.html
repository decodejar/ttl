<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TAO Tensor Law Model — by decodejar</title>
    <!-- ===== FAVICON TAGS ===== -->
    <link rel="icon" href="/decode-favicon.png" type="image/png">
    <link rel="shortcut icon" href="/decode-favicon.png" type="image/png">
    <link rel="apple-touch-icon" href="/decode-favicon.png">
    <!-- ===== END FAVICON TAGS ===== -->
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-EXV4MXZNHJ"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-EXV4MXZNHJ');
    </script>    
    <!-- External Libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Courgette&display=swap" rel="stylesheet">
    <!-- Internal Styles -->
    <style>
        body { font-family: 'Inter', sans-serif; }
        .font-handwriting { font-family: 'Courgette', cursive; }
        /* Loader animation */
        .loader {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #ff6d00;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        /* Colored status dot */
        .status-dot {
            height: 10px;
            width: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
        
        /* --- Fullscreen CSS Logic --- */
        
        /* Override body flex-centering when in fullscreen */
        body:has(#mainContainer:fullscreen) {
            display: block;
        }

        /* Main container expands to fill viewport in fullscreen */
        #mainContainer:fullscreen {
            width: 100vw;
            height: 100vh;
            max-width: none !important;
            border-radius: 0 !important;
            display: flex;
            flex-direction: column;
        }

        /* Chart card grows to fill available space */
        #mainContainer:fullscreen #chartCard {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }

        /* Chart wrapper (which contains canvas) grows */
        #mainContainer:fullscreen #chartWrapper {
            height: 100% !important;
            flex-grow: 1;
        }

        /* Hide footer when in fullscreen */
        body:has(#mainContainer:fullscreen) footer {
            display: none;
        }

        /* --- Mobile Fullscreen Optimizations --- */

        /* Show "Please Rotate" overlay in portrait fullscreen */
        @media (max-width: 639px) and (orientation: portrait) {
            #mainContainer:fullscreen #rotateOverlay {
                display: flex !important;
            }
            /* Hide all other UI elements */
            #mainContainer:fullscreen header,
            #mainContainer:fullscreen #topStatusBar,
            #mainContainer:fullscreen #chartCard,
            #mainContainer:fullscreen #bottomModelBar,
            #mainContainer:fullscreen #fullscreenBtn {
                display: none !important;
            }
        }

        /* Styles applied by JS for mobile LANDSCAPE fullscreen */
        #mainContainer.mobile-fullscreen-landscape {
             padding-top: 0.375rem !important;       /* py-1.5 */
             padding-bottom: 0.375rem !important; /* py-1.5 */
        }
        
        #mainContainer.mobile-fullscreen-landscape #bottomModelBar {
             display: none !important;
        }
         #mainContainer.mobile-fullscreen-landscape #chartCard {
             padding: 0 !important;
        }
         #mainContainer.mobile-fullscreen-landscape #topStatusBar {
             display: flex !important;
             padding: 0.125rem 0.5rem !important; /* p-0.5 px-2 */
             margin-bottom: 0.125rem !important; /* mb-0.5 */
             gap: 0.5rem 1rem !important; /* gap-y-2 gap-x-4 */
             font-size: 0.75rem !important; /* text-xs */
        }
        #mainContainer.mobile-fullscreen-landscape header {
             height: 2.25rem !important; /* h-9 */
             margin-bottom: 0.125rem !important; /* mb-0.5 */
        }
        #mainContainer.mobile-fullscreen-landscape header h1 {
             font-size: 1.125rem !important; /* text-lg */
        }
        #mainContainer.mobile-fullscreen-landscape header img {
             width: 1.75rem !important; /* w-7 */
             height: 1.75rem !important; /* h-7 */
        }
        #mainContainer.mobile-fullscreen-landscape #fullscreenBtn svg {
             width: 1.25rem !important; /* w-5 */
             height: 1.25rem !important; /* h-5 */
        }
        #mainContainer.mobile-fullscreen-landscape #headerLinkWrapper {
             font-size: 0.75rem !important; /* text-xs */
             line-height: 1rem !important; /* leading-4 */
        }
        /* Hides the first link (Twitter/X) and the separator span in mobile landscape fullscreen */
        #mainContainer.mobile-fullscreen-landscape #headerLinkWrapper a:first-of-type,
        #mainContainer.mobile-fullscreen-landscape #headerLinkWrapper span {
             display: none !important;
        }
        
        /* --- END: Mobile Fullscreen Optimizations --- */

        /* --- Projection & Band Table Styles --- */
        #projectionTable,
        #bandLevelsTable {
            position: absolute;
            top: 12%;
            z-index: 5; /* Below loader (10) but above chart */
            background-color: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(4px);
            border-radius: 0.5rem; /* rounded-lg */
            padding: 0.5rem 0.75rem; /* p-2 p-3 */
            font-size: 0.75rem; /* text-xs */
            line-height: 1.15rem;
            color: #374151; /* text-gray-700 */
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1); /* shadow-md */
            border: 1px solid rgba(0, 0, 0, 0.05);
            width: max-content; /* UPDATED: Hugs content tightly */
            /* Removed min-width: 180px to eliminate whitespace */
        }
        #projectionTable { left: 10%; }
        #bandLevelsTable { left: 10%; }

        #projectionTable h3,
        #bandLevelsTable h3 {
            font-weight: 600; /* font-semibold */
            color: #1f2937; /* text-gray-800 */
            margin-bottom: 0.25rem; /* mb-1 */
            border-bottom: 1px solid rgba(0,0,0,0.1);
            padding-bottom: 0.25rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
            user-select: none;
        }

        /* Use direct child selector to avoid styling nested divs */
        #projectionData > div,
        #bandLevelsTable > div:not(h3) { /* Exclude h3 from this rule */
            display: flex;
            justify-content: space-between;
        }

        #projectionData > div span:first-child,
        #bandLevelsTable > div:not(h3) span:first-child {
            margin-right: 1.25rem; /* mr-5 */
            color: #4b5563; /* text-gray-600 */
        }
        #projectionData > div span:last-child,
        #bandLevelsTable > div:not(h3) span:last-child {
            font-weight: 500; /* font-medium */
            color: #1f2937; /* text-gray-800 */
        }
        #projectionTable h3 button,
        #bandLevelsTable h3 button {
            margin-left: 0.5rem; /* ml-2 */
            color: #9ca3af; /* text-gray-400 */
            cursor: pointer;
            background: none;
            border: none;
            padding: 0;
            line-height: 1;
        }
        #projectionTable h3 button:hover,
        #bandLevelsTable h3 button:hover { color: #374151; }
        /* --- END: Projection & Band Table Styles --- */
        
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col items-center h-screen p-2">

    <!-- SEO text for search engines -->
    <div class="sr-only">
        This interactive chart models the price history of TAO (Bittensor) against a logarithmic power law regression (Price = C * (Time + Offset)^α). With an optimal time offset for best fit, it calculates the 'fair value' trend line and price rating bands (discount, value, expensive, bubble) to help visualize TAO's historical valuation. The tool includes features to toggle bands, pan, zoom, and see future price projections based on this long-term model. The TAO Tensor Law Model was created by decodejar (x.com/decodejar, decodejar.com).
    </div>

    <!-- Main application container -->
    <div id="mainContainer" class="w-full flex-grow max-w-[1920px] max-h-[1080px] min-h-[30rem] flex flex-col bg-white rounded-lg shadow-xl p-2 sm:p-3 md:p-4 relative">

        <!-- Mobile Rotate Overlay -->
        <div id="rotateOverlay" class="hidden absolute inset-0 w-full h-full bg-white/95 z-50 flex-col items-center justify-center text-center p-8">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-16 h-16 text-gray-600 mb-4 animate-pulse">
                <path stroke-linecap="round" stroke-linejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.992 0 3.181 3.183a8.25 8.25 0 0 0 13.803-3.7M4.031 9.865a8.25 8.25 0 0 1 13.803-3.7l3.181 3.182m0-4.991v4.99" />
            </svg>
            <h2 class="text-2xl font-semibold text-gray-800 mb-2">Please Rotate Your Device</h2>
            <p class="text-gray-600">This chart is best viewed in landscape mode.</p>
        </div>

        <!-- Page Header -->
        <header class="relative mb-3 h-10 flex items-center justify-between">
            <!-- Left Element: Logo and Links -->
            <div class="flex items-center gap-3">
                <!-- Image link -->
                <a href="https://x.com/decodejar" target="_blank" rel="noopener noreferrer" class="flex-shrink-0">
                    <img src="decode.png" alt="Decode Logo" class="w-10 h-10 rounded-full border border-gray-200" onerror="this.src='https://placehold.co/40x40/eeeeee/333333?text=D'; this.onerror=null;">
                </a>
                <!-- Text links wrapper: Always stacked when visible -->
               <div id="headerLinkWrapper" class="hidden sm:flex flex-col items-start gap-0 text-sm text-gray-600 sm:leading-4 md:leading-5 md:text-gray-800 lg:text-gray-900">
                    <a href="https://x.com/decodejar" target="_blank" rel="noopener noreferrer" class="hover:text-indigo-500 transition-colors">
                        x.com/decodejar
                    </a>
                    <a href="https://decodejar.com" target="_blank" rel="noopener noreferrer" class="hover:text-indigo-500 transition-colors">
                        decodejar.com
                    </a>
                </div>
            </div>

            <!-- Center Element: Title (Absolutely centered) -->
            <div class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 flex items-center space-x-2">
                <h1 class="text-xl sm:text-2xl md:text-3xl text-gray-900 whitespace-nowrap flex items-center">
                    TAO Tensor Law Model
                    <span class="hidden lg:inline ml-2 text-xl text-gray-500 font-handwriting font-normal">&mdash; by decodejar</span>
                </h1>
                <!-- Tooltip Icon -->
                <span title="This interactive chart models the price history of TAO (Bittensor) against a logarithmic power law regression (Price = C * (Time + Offset)^α). With an optimal time offset for best fit, it calculates the 'fair value' trend line and price rating bands (discount, value, expensive, bubble) to help visualize TAO's historical valuation. The tool includes features to toggle bands, pan, zoom, and see future price projections based on this long-term model. The TAO Tensor Law Model was created by decodejar (x.com/decodejar, decodejar.com)." class="text-xs text-gray-600 cursor-help border border-gray-600 rounded-full w-4 h-4 flex items-center justify-center hover:bg-gray-300">?</span>
            </div>

             <!-- Right Element: Fullscreen Button -->
            <button id="fullscreenBtn" onclick="toggleFullScreen()" class="text-gray-400 hover:text-gray-800 transition-colors z-20 p-1 rounded-full hover:bg-gray-100" title="Toggle Fullscreen">
                <svg id="fsIconEnter" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9 15M20.25 3.75h-4.5m4.5 0v4.5m0-4.5L15 9m4.5 11.25h-4.5m4.5 0v-4.5m0 4.5L15 15" />
                </svg>
                <svg id="fsIconExit" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6 hidden">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M9 9L3.75 3.75M9 9h4.5m-4.5 0v4.5m0-4.5L3.75 3.75M9 15l-5.25 5.25M9 15h4.5m-4.5 0v-4.5m0 4.5l-5.25 5.25M15 9l5.25-5.25M15 9h-4.5m4.5 0v4.5m0-4.5l5.25-5.25M15 15l5.25 5.25M15 15h-4.5m4.5 0v-4.5m0 4.5l5.25 5.25" />
                </svg>
            </button>
        </header>

        <!-- Top Status Bar: Data status, price, bands toggle -->
        <div id="topStatusBar" class="bg-gray-100 p-1 rounded-lg flex flex-wrap items-center justify-center gap-x-6 gap-y-2 mb-2 text-sm text-gray-600 px-4">
             <div id="dataStatusDiv" class="flex items-center">
                 <span class="status-dot bg-yellow-400"></span><strong>Updated:</strong>&nbsp;N/A (Loading)
             </div>
             <div id="lastPriceDiv" class="hidden sm:block"></div>
             <div id="priceZoneDiv" class="flex items-center hidden sm:block"></div>
             
             <!-- Bands Toggle Checkbox -->
             <div id="showBandsContainer" class="flex items-center hidden">
                 <input type="checkbox" id="showBandsCheckbox" class="mr-1.5 h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                 <label for="showBandsCheckbox" class="cursor-pointer mr-1">Show Bands&nbsp;</label>
                 <span title="Blue: Discount (P1-P20), Green: Value (P20-P50), Yellow: Expensive (P50-P80), Red: Bubble (P80-P99)" class="text-xs text-gray-600 cursor-help border border-gray-600 rounded-full w-4 h-4 flex items-center justify-center hover:bg-gray-300">?</span>
             </div>
        </div>

        <!-- Chart Card: Contains loader and canvas wrapper -->
        <div id="chartCard" class="bg-white p-2 rounded-lg relative flex-grow flex flex-col min-h-0">
            <!-- Loading Spinner -->
            <div id="loader" class="absolute inset-0 bg-white/80 flex items-center justify-center z-10">
                <div class="loader"></div>
            </div>
            <!-- Canvas Wrapper: Scales to fill parent card -->
            <div id="chartWrapper" class="relative flex-grow min-h-0">
                
                <!-- UPDATED: Projection Table with Static Header for Drag Support -->
                <div id="projectionTable" class="hidden">
                    <h3 id="projectionHeader">
                        <span>Fair Value</span>
                        <button onclick="document.getElementById('projectionTable').style.display='none'" type="button" title="Close">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-4 h-4">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                            </svg>
                        </button>
                    </h3>
                    <div id="projectionData"></div> <!-- Data rows will be injected here -->
                </div>

                <!-- UPDATED: Band Levels Table with Static Header ID -->
                <div id="bandLevelsTable" class="hidden">
                    <h3 id="bandsHeader">
                        <span>Current Bands</span>
                        <button onclick="document.getElementById('bandLevelsTable').style.display='none'" type="button" title="Close">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-4 h-4">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                            </svg>
                        </button>
                    </h3>
                    <div id="bandLevelBubble">
                        <span class="inline-flex items-center">
                            <span class="status-dot bg-red-500 flex-shrink-0"></span>
                            <span class="whitespace-nowrap">Bubble</span>
                        </span>
                        <span class="whitespace-nowrap">$N/A - $N/A</span>
                    </div>
                    <div id="bandLevelExpensive">
                        <span class="inline-flex items-center">
                            <span class="status-dot bg-yellow-400 flex-shrink-0"></span>
                            <span class="whitespace-nowrap">Expensive</span>
                        </span>
                        <span class="whitespace-nowrap">$N/A - $N/A</span>
                    </div>
                    <div id="bandLevelValue">
                        <span class="inline-flex items-center">
                            <span class="status-dot bg-green-500 flex-shrink-0"></span>
                            <span class="whitespace-nowrap">Value</span>
                        </span>
                        <span class="whitespace-nowrap">$N/A - $N/A</span>
                    </div>
                    <div id="bandLevelDiscount">
                        <span class="inline-flex items-center">
                            <span class="status-dot bg-blue-300 flex-shrink-0"></span>
                            <span class="whitespace-nowrap">Discount</span>
                        </span>
                        <span class="whitespace-nowrap">$N/A - $N/A</span>
                    </div>
                </div>
                <!-- END: Band Levels Table -->
                
                <canvas id="powerLawChart"></canvas>
            </div>
        </div>

        <!-- Bottom Model Info Bar -->
        <div id="bottomModelBar" class="bg-gray-100 p-1 rounded-lg flex flex-wrap items-center justify-center gap-x-6 gap-y-2 mt-2 text-sm text-gray-600 px-4">
            <div id="growthExponentDiv"></div>              
            <div id="modelParamDiv"></div>
                <div class="flex items-center">
                    <input type="checkbox" id="useOptimalOffsetCheckbox" class="mr-1.5 h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500" checked>
                    <label for="useOptimalOffsetCheckbox" class="cursor-pointer mr-1">Use Optimal&nbsp;</label>
                    <span title="Overrides the hard-coded model offset and uses the dynamically calculated optimal fit." class="text-xs text-gray-600 cursor-help border border-gray-600 rounded-full w-4 h-4 flex items-center justify-center hover:bg-gray-300">?</span>
                </div>
                <div id="modelFitDiv"></div>
            </div>
        </div>
    </div>

    <!-- Footer -->
    <footer class="pt-4 px-4 pb-1 text-center text-xs sm:text-xxs text-gray-400 space-y-2">
        <p class="text-gray-400 text-xs">Disclaimer: This content is for informational and research purposes only, reflects the author's opinion, and is not financial, investment or trading advice. The cryptocurrency market is volatile; invest at your own risk and only what you can afford to lose. Past performance does not guarantee future results.</p>
        <p class="text-gray-400 text-xs">&copy; 2025 TAOTENSORLAW.COM. All Rights Reserved.</p>
    </footer>


    <script>
        /*
         * TAO Tensor Law Model — by decodejar
         * Copyright (c) 2025 TAOTENSORLAW.COM. All Rights Reserved.
         */

        // --- SECTION: GLOBAL ELEMENT REFERENCES ---
        const mainContainer = document.getElementById('mainContainer');
        const headerElement = document.querySelector('header');
        const topBarElement = document.getElementById('topStatusBar');
        const bottomBarElement = document.getElementById('bottomModelBar');
        const chartCardElement = document.getElementById('chartCard');
        const fsIconEnter = document.getElementById('fsIconEnter');
        const fsIconExit = document.getElementById('fsIconExit');
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const growthExponentDiv = document.getElementById('growthExponentDiv');
        const modelFitDiv = document.getElementById('modelFitDiv');
        const loader = document.getElementById('loader');
        const dataStatusDiv = document.getElementById('dataStatusDiv');
        const lastPriceDiv = document.getElementById('lastPriceDiv');
        const priceZoneDiv = document.getElementById('priceZoneDiv');
        const ctx = document.getElementById('powerLawChart').getContext('2d');
        const modelParamDiv = document.getElementById('modelParamDiv');
        const showBandsContainer = document.getElementById('showBandsContainer');
        const showBandsCheckbox = document.getElementById('showBandsCheckbox');
        const projectionTable = document.getElementById('projectionTable');
        const projectionData = document.getElementById('projectionData');
        const bandLevelsTable = document.getElementById('bandLevelsTable');
        const useOptimalOffsetCheckbox = document.getElementById('useOptimalOffsetCheckbox');

        // --- SECTION: CHART CONFIGURATION & CONSTANTS ---

        const HARDCODED_OFFSET = 74;
        const MAX_OFFSET_SEARCH_LIMIT = 730;    
        const X_AXIS_PROJECTION_PADDING = 0.33; 
        const Y_AXIS_BOTTOM_PADDING = 0.1;
        const Y_AXIS_TOP_PADDING_MIN = 0.1;
        const Y_AXIS_TOP_PADDING_MAX = 0.33;
        
        let chart; 
        let baseData = []; 
        let priceData = []; 
        let activeModelParams = {}; 
        
        // Zoom & Pan State
        let originalExtendedMinDay = 1;
        let originalExtendedMaxDay = 1000;
        const ZOOM_FACTOR = 0.1;
        let isPanning = false;
        let panStartX = 0;
        let panStartMin = 0;
        let panStartLogRange = 0;

        // Band Fill Colors
        const blueFillColor = 'rgba(147, 197, 253, 0.1)';
        const greenFillColor = 'rgba(34, 197, 94, 0.1)';
        const yellowFillColor = 'rgba(250, 204, 21, 0.1)';
        const redFillColor = 'rgba(239, 68, 68, 0.1)';

        // Reusable Line Styles
        const grayLineStyle = { borderColor: 'rgba(156, 163, 175, 0.7)', borderWidth: 1, borderDash: [] };
        const orangeLineStyle = { borderColor: '#ff6d00', borderWidth: 2, borderDash: [] };
        const grayDashedLineStyle = { borderColor: 'rgba(156, 163, 175, 0.9)', borderWidth: 1, borderDash: [4, 4] };
        const grayFineLineStyle = { borderColor: 'rgba(156, 163, 175, 0.7)', borderWidth: 0.5, borderDash: [] };

        /**
         * Chart.js plugin to add a watermark to the background.
         */
        const watermarkPlugin = {
            id: 'watermark',
            afterDraw: (chart, args, options) => {
                const { ctx, chartArea: { top, right, bottom, left, width, height } } = chart;
                
                if (width <= 0 || height <= 0) return; 

                ctx.save();
                const text = 'taotensorlaw.com';
                
                const baseFontSize = Math.max(30, Math.min(80, width / 12)); 
                ctx.font = `bold ${baseFontSize.toFixed(0)}px Inter, sans-serif`;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.075)'; 
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                const centerX = left + width / 2;
                const centerY = top + height / 2;
                ctx.fillText(text, centerX, centerY);
                
                ctx.restore();
            }
        };
        Chart.register(watermarkPlugin);

        // --- SECTION: DATA & REGRESSION LOGIC ---

        async function loadPriceData() {
            try {
                const response = await fetch(`./price_data.json?t=${new Date().getTime()}`);
                if (!response.ok) throw new Error(`Failed to load data file: ${response.statusText}`);
                const data = await response.json();
                 if (!Array.isArray(data)) throw new Error("Invalid data format in JSON file");
                baseData = data.map((p, i) => ({ time: p[0] * 1000, dayIndex: i + 1, y: p[1] })).filter(p => p.y > 0);
                return baseData;
            } catch (error) {
                console.error("Error loading price data:", error);
                dataStatusDiv.innerHTML = `<span class="status-dot bg-red-500"></span><strong>Updated:</strong>&nbsp;N/A (Error)`;
                loader.style.display = 'none';
                return null;
            }
        }

        function linearRegression(data) {
            let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
            const validData = data.filter(p => p.y > 0 && p.x > 0);
            const n = validData.length;
            if (n < 2) return { slope: 0, intercept: 0 }; 
            
            for (const { x, y } of validData) {
                const logX = Math.log10(x);
                const logY = Math.log10(y);
                sumX += logX; sumY += logY; sumXY += logX * logY; sumX2 += logX * logX;
            }

            const denominator = (n * sumX2 - sumX * sumX);
            if (denominator === 0) return { slope: 0, intercept: 0 }; 
            
            const slope = (n * sumXY - sumX * sumY) / denominator;
            const intercept = (sumY - slope * sumX) / n;
            return { slope, intercept };
        }

        function calculateResiduals(data, slope, intercept) {
            const validData = data.filter(p => p.y > 0 && p.x > 0);
            if (validData.length === 0) return [];
            return validData.map(p => {
                const logX = Math.log10(p.x);
                const logY = Math.log10(p.y);
                const predictedLogY = slope * logX + intercept;
                return logY - predictedLogY;
            }).sort((a, b) => a - b); 
        }

        function getPercentile(sortedResiduals, percentile) {
            if (!sortedResiduals || sortedResiduals.length === 0) return 0;
            const index = (percentile / 100) * (sortedResiduals.length - 1);
            const lowerIndex = Math.floor(index);
            const upperIndex = Math.ceil(index);
            
            if (lowerIndex === upperIndex) {
                 return sortedResiduals[lowerIndex];
            } else {
                 const weight = index - lowerIndex;
                 return sortedResiduals[lowerIndex] * (1 - weight) + sortedResiduals[upperIndex] * weight;
            }
        }

        function findOptimalOffset(baseData, minOffset = 1, maxOffset) {
            let bestOffset = -1;
            let bestRSquared = -Infinity;

            if (baseData.length < 2) return { optimalOffset: -1, bestFit: 0 };
            if (typeof maxOffset === 'undefined' || maxOffset < minOffset) maxOffset = baseData.length; 

            for (let offset = minOffset; offset <= maxOffset; offset++) {
                const offsetData = baseData.map(p => ({ x: p.dayIndex + offset, y: p.y }));
                const { slope, intercept } = linearRegression(offsetData);
                if (slope === 0 && intercept === 0 && offsetData.length > 1) continue; 
                
                const rSquared = calculateRSquared(offsetData, slope, intercept);
                if (rSquared > bestRSquared) {
                    bestRSquared = rSquared;
                    bestOffset = offset;
                }
            }
            return { optimalOffset: bestOffset, bestFit: bestRSquared };
        }

        // --- SECTION: CORE APPLICATION LOGIC ---

        async function createOrUpdateChart() {
            loader.style.display = 'flex';
            
            if (baseData.length === 0) {
                await loadPriceData();
            }

            if (!baseData || baseData.length === 0) {
                if (!dataStatusDiv.innerHTML.includes('Error')) { 
                    dataStatusDiv.innerHTML = `<span class="status-dot bg-red-500"></span><strong>Updated:</strong>&nbsp;N/A`;
                }
                growthExponentDiv.innerHTML = '<strong>Exponent (α):</strong> N/A';
                modelParamDiv.innerHTML = '<strong>Day Offset:</strong> N/A';
                modelFitDiv.innerHTML = '<strong>Fit (R²):</strong> N/A';
                if (useOptimalOffsetCheckbox) useOptimalOffsetCheckbox.disabled = true;
                showBandsContainer.classList.add('hidden');
                loader.style.display = 'none';
                return;
            }

            const useOptimal = useOptimalOffsetCheckbox.checked;
            let slope, meanIntercept, rSquared;
            let activeDayOffset;
            
            const { optimalOffset, bestFit: optimalOffsetRSquared } = findOptimalOffset(baseData, 1, MAX_OFFSET_SEARCH_LIMIT);
            
            if (useOptimal) {
                activeDayOffset = optimalOffset;
                priceData = baseData.map(p => ({ ...p, x: p.dayIndex + optimalOffset }));
                const regression = linearRegression(priceData);
                slope = regression.slope;
                meanIntercept = regression.intercept;
                rSquared = optimalOffsetRSquared; 
                modelParamDiv.innerHTML = `<strong>Day Offset:</strong> ${optimalOffset}`;
            } else {
                activeDayOffset = HARDCODED_OFFSET;
                priceData = baseData.map(p => ({ ...p, x: p.dayIndex + HARDCODED_OFFSET }));
                const regression = linearRegression(priceData);
                slope = regression.slope;
                meanIntercept = regression.intercept;
                rSquared = calculateRSquared(priceData, slope, meanIntercept);
                if (optimalOffset !== -1 && optimalOffset !== HARDCODED_OFFSET) {
                      modelParamDiv.innerHTML = `<strong>Day Offset:</strong> ${HARDCODED_OFFSET} | <strong>Optimal:</strong> ${optimalOffset} (R² ${optimalOffsetRSquared.toFixed(4)})`;
                } else {
                      modelParamDiv.innerHTML = `<strong>Day Offset:</strong> ${HARDCODED_OFFSET}`;
                }
            }
            
            activeModelParams = {
                modelType: useOptimal ? 'optimalOffset' : 'hardcoded',
                activeDayOffset: activeDayOffset,
                slope: slope,
                meanIntercept: meanIntercept
            };

            if (useOptimalOffsetCheckbox) useOptimalOffsetCheckbox.disabled = false;
            
            const lastBaseDataPoint = baseData[baseData.length - 1]; 
            const lastTimestamp = lastBaseDataPoint.time; 
            const lastUpdateDate = new Date(lastTimestamp).toLocaleDateString(undefined, {
                year: 'numeric', month: 'short', day: 'numeric'
            });

            const now = new Date().getTime();
            const diffMs = now - lastTimestamp;
            const oneDayMs = 24 * 60 * 60 * 1000;
            const sevenDaysMs = 7 * oneDayMs;

            let dotColor = "bg-red-500"; 
            if (diffMs < oneDayMs) {
                dotColor = "bg-green-500"; 
            } else if (diffMs < sevenDaysMs) {
                dotColor = "bg-yellow-400"; 
            }
            
            dataStatusDiv.innerHTML = `<span class="status-dot ${dotColor}"></span><strong>Updated:</strong>&nbsp;${lastUpdateDate}`;

            lastPriceDiv.innerHTML = `<strong>Price:</strong> $${lastBaseDataPoint.y.toFixed(2)}`;
            lastPriceDiv.classList.remove('hidden');

            const chartPrices = priceData.map(p => p.y);
            const minPrice = Math.min(...chartPrices);
            const maxPrice = Math.max(...chartPrices);

            const firstDayNum = priceData[0].x;
            const lastDayNum = priceData[priceData.length - 1].x; 

            const logMinDay = Math.log10(firstDayNum);
            const logMaxDay = Math.log10(lastDayNum);
            const logDayRange = logMaxDay - logMinDay;

            const extendedMinDay = firstDayNum;
            let extendedMaxDay;

            if (logDayRange > 0) {
                const extendedLogMaxDay = logMaxDay + (logDayRange * X_AXIS_PROJECTION_PADDING);
                extendedMaxDay = Math.pow(10, extendedLogMaxDay);
            } else {
                extendedMaxDay = lastDayNum * 1.4; 
            }

            originalExtendedMinDay = extendedMinDay;
            originalExtendedMaxDay = extendedMaxDay;

            const logMinPrice = Math.log10(minPrice);
            const logMaxPrice = Math.log10(maxPrice);
            const logPriceRange = logMaxPrice - logMinPrice;
            const extendedMinPrice = logPriceRange > 0 ? Math.pow(10, logMinPrice - logPriceRange * Y_AXIS_BOTTOM_PADDING) : minPrice * 0.9; 
            const extendedMaxPrice = logPriceRange > 0 ? Math.pow(10, logMaxPrice + logPriceRange * Y_AXIS_TOP_PADDING_MAX) : maxPrice * 1.4; 

            const lastModelDataPoint = priceData[priceData.length - 1];
            const sortedResiduals = calculateResiduals(priceData, slope, meanIntercept);

            const medianResidual = getPercentile(sortedResiduals, 50);
            const p1Residual = getPercentile(sortedResiduals, 1);
            const p99Residual = getPercentile(sortedResiduals, 99);
            const p20Residual = getPercentile(sortedResiduals, 20);
            const p80Residual = getPercentile(sortedResiduals, 80);

            const lastLogX = Math.log10(lastModelDataPoint.x);
            const lastLogY = Math.log10(lastModelDataPoint.y);
            const predictedLastLogY = slope * lastLogX + meanIntercept;
            const lastResidual = lastLogY - predictedLastLogY;

            let priceZone = "";
            let priceZoneColor = "";
            if (lastResidual > p80Residual) { priceZone = "Bubble"; priceZoneColor = "bg-red-500"; }
            else if (lastResidual > medianResidual) { priceZone = "Expensive"; priceZoneColor = "bg-yellow-400"; }
            else if (lastResidual > p20Residual) { priceZone = "Value"; priceZoneColor = "bg-green-500"; }
            else { priceZone = "Discount"; priceZoneColor = "bg-blue-300"; }

            priceZoneDiv.innerHTML = `<span class="status-dot ${priceZoneColor}"></span><strong>Rating:</strong>&nbsp;${priceZone}`;
            priceZoneDiv.classList.remove('hidden');

            const medianIntercept = meanIntercept + medianResidual;
            const p1Intercept = meanIntercept + p1Residual;
            const p99Intercept = meanIntercept + p99Residual;
            const p20Intercept = meanIntercept + p20Residual;
            const p80Intercept = meanIntercept + p80Residual;

            if (bandLevelsTable) {
                const lastP1Price = Math.pow(10, slope * lastLogX + p1Intercept);
                const lastP20Price = Math.pow(10, slope * lastLogX + p20Intercept);
                const lastP50Price = Math.pow(10, slope * lastLogX + medianIntercept);
                const lastP80Price = Math.pow(10, slope * lastLogX + p80Intercept);
                const lastP99Price = Math.pow(10, slope * lastLogX + p99Intercept);

                const bubbleEl = document.querySelector('#bandLevelsTable #bandLevelBubble > span:last-child');
                const expensiveEl = document.querySelector('#bandLevelsTable #bandLevelExpensive > span:last-child');
                const valueEl = document.querySelector('#bandLevelsTable #bandLevelValue > span:last-child');
                const discountEl = document.querySelector('#bandLevelsTable #bandLevelDiscount > span:last-child');

                if (bubbleEl) bubbleEl.textContent = `$${lastP80Price.toFixed(2)} - $${lastP99Price.toFixed(2)}`;
                if (expensiveEl) expensiveEl.textContent = `$${lastP50Price.toFixed(2)} - $${lastP80Price.toFixed(2)}`;
                if (valueEl) valueEl.textContent = `$${lastP20Price.toFixed(2)} - $${lastP20Price.toFixed(2)}`;
                if (discountEl) discountEl.textContent = `$${lastP1Price.toFixed(2)} - $${lastP20Price.toFixed(2)}`;
            }
            
            calculateProjections(baseData, activeModelParams, projectionData);

            growthExponentDiv.innerHTML = `<strong>Exponent (α):</strong> ${slope.toFixed(3)}`;
            
            let fitColorClass = "";
            if (rSquared >= 0.9) fitColorClass = "bg-blue-300";
            else if (rSquared >= 0.7) fitColorClass = "bg-green-500";
            else if (rSquared >= 0.5) fitColorClass = "bg-yellow-400";
            else fitColorClass = "bg-red-500";
            
            modelFitDiv.innerHTML = `<span class="status-dot ${fitColorClass}"></span><strong>Fit (R²):</strong> ${rSquared.toFixed(4)}`;
            
            const startIndex = extendedMinDay;
            const endIndex = extendedMaxDay;
            const calculateLinePoints = (intercept) => {
                 const safeStartIndex = Math.max(startIndex, 1); 
                 const safeEndIndex = Math.max(endIndex, 1);
                 return [
                     { x: startIndex, y: Math.pow(10, slope * Math.log10(safeStartIndex) + intercept) },
                     { x: endIndex, y: Math.pow(10, slope * Math.log10(safeEndIndex) + intercept) }
                 ];
            };
            const medianLineData = calculateLinePoints(medianIntercept);
            const p1LineData = calculateLinePoints(p1Intercept);
            const p99LineData = calculateLinePoints(p99Intercept);
            const p20LineData = calculateLinePoints(p20Intercept);
            const p80LineData = calculateLinePoints(p80Intercept);

            const chartPriceDataPoints = priceData.map(p => ({ x: p.x, y: p.y }));

            loader.style.display = 'none';

            const xAxisAfterBuildTicks = (axis) => {
                 if (!priceData || priceData.length === 0 || !baseData || baseData.length === 0) return;
                 
                 const newTicks = [];
                 const axisMinDay = axis.min;
                 const axisMaxDay = axis.max;

                 const { activeDayOffset } = activeModelParams;

                 const firstDayIndex = baseData[0].dayIndex;
                 const firstDayTime = baseData[0].time;
                 const lastDayIndex = baseData[baseData.length - 1].dayIndex;
                 const lastDayTime = baseData[baseData.length - 1].time;
                 
                 let maxYear;
                 let msPerDay = (1000 * 60 * 60 * 24); 

                 if (lastDayIndex > firstDayIndex) {
                     msPerDay = (lastDayTime - firstDayTime) / (lastDayIndex - firstDayIndex);
                     const maxDayIndexOnAxis = axisMaxDay - activeDayOffset;
                     const projectedTime = firstDayTime + (maxDayIndexOnAxis - firstDayIndex) * msPerDay;
                     maxYear = new Date(projectedTime).getFullYear();
                 } else {
                     maxYear = new Date(lastDayTime).getFullYear() + 5;
                 }
                 
                 let lastYearFound = -1; 
                 const firstDataYear = new Date(baseData[0].time).getFullYear();
                 const lastDataYear = new Date(lastDayTime).getFullYear();

                 for (let year = firstDataYear; year <= lastDataYear; year++) {
                   const yearStartTime = new Date(year, 0, 1).getTime();
                   const dayData = baseData.find(p => p.time >= yearStartTime);
                   
                   if (!dayData) continue;
                   
                   const actualYear = new Date(dayData.time).getFullYear();
                   if (actualYear > year && year > firstDataYear) continue; 

                   if (year > lastYearFound) {
                        const xValue = dayData.dayIndex + activeDayOffset;
                        if (xValue >= axisMinDay && xValue <= axisMaxDay) {
                             newTicks.push({ value: xValue, label: year.toString() });
                             lastYearFound = year;
                        }
                   }
                 }

                 for (let year = lastDataYear + 1; year <= maxYear; year++) {
                   const yearStartTime = new Date(year, 0, 1).getTime();
                   
                   const diffTime = yearStartTime - firstDayTime;
                   const estimatedDayIndex = firstDayIndex + (diffTime / msPerDay);
                   
                   const xValue = estimatedDayIndex + activeDayOffset;

                   if (xValue >= axisMinDay && xValue <= axisMaxDay) {
                         newTicks.push({ value: xValue, label: year.toString() });
                   }
                 }
                 
                 axis.ticks.length = 0; 
                 const validTicks = newTicks.filter(tick => !isNaN(tick.value) && tick.label);
                 axis.ticks.push(...validTicks);
             };

            function yAxisAfterBuildTicks(axis) {
                const newTicks = [];
                const min = axis.min;
                const max = axis.max;

                let startingPower = Math.floor(Math.log10(min));
                let currentMagnitude = Math.pow(10, startingPower); 

                while (currentMagnitude < max) {
                    for (let i = 1; i <= 9; i++) {
                        const tickValue = currentMagnitude * i;
                        if (tickValue > max) break; 
                        if (tickValue >= min) {
                            newTicks.push({ value: tickValue });
                        }
                    }
                    currentMagnitude *= 10; 
                }

                axis.ticks.length = 0; 
                axis.ticks.push(...newTicks);
            }

            const datasetDefaults = {
                type: 'line', borderWidth: 1, pointRadius: 0, fill: false, pointStyle: 'line'
            };
            const fillDatasetDefaults = {
                type: 'line', pointRadius: 0, borderWidth: 0, pointStyle: 'line', tension: 0.1
            };

            if (chart) {
                // 1. Update Data Arrays for Reused Datasets
                // We need to ensure the chart has enough datasets slots or push new ones
                // The new structure requires 11 datasets total (0-10).
                
                // Define the data structure for the 11 layers
                const datasetsStruct = [
                    // --- BOUNDARY/FILL LAYERS (0-4) ---
                    // 0: Boundary P1 (Base for Discount)
                    { label: 'Boundary P1', data: p1LineData, borderColor: 'transparent', fill: false },
                    // 1: Discount Band (P1-P20) - Fills to 0
                    { label: 'Discount Band (P1-P20)', data: p20LineData, borderColor: 'transparent', backgroundColor: blueFillColor, fill: 0 },
                    // 2: Value Band (P20-P50) - Fills to 1
                    { label: 'Value Band (P20-P50)', data: medianLineData, borderColor: 'transparent', backgroundColor: greenFillColor, fill: 1 },
                    // 3: Expensive Band (P50-P80) - Fills to 2
                    { label: 'Expensive Band (P50-P80)', data: p80LineData, borderColor: 'transparent', backgroundColor: yellowFillColor, fill: 2 },
                    // 4: Bubble Band (P80-P99) - Fills to 3
                    { label: 'Bubble Band (P80-P99)', data: p99LineData, borderColor: 'transparent', backgroundColor: redFillColor, fill: 3 },

                    // --- VISUAL LINE LAYERS (5-10) ---
                    // 5: Price
                    { label: 'TAO Price', data: chartPriceDataPoints, borderColor: 'rgba(0, 0, 0, 1)', borderWidth: 2, backgroundColor: 'rgba(0, 0, 0, 0.05)' },
                    // 6: Median Line (P50)
                    { label: '50th Percentile', data: medianLineData }, 
                    // 7: 1st Pctl
                    { label: '1st Pctl', data: p1LineData },
                    // 8: 99th Pctl
                    { label: '99th Pctl', data: p99LineData },
                    // 9: 20th Pctl
                    { label: '20th Pctl', data: p20LineData },
                    // 10: 80th Pctl
                    { label: '80th Pctl', data: p80LineData },
                ];

                // Apply updates to existing chart datasets or push new ones
                datasetsStruct.forEach((struct, i) => {
                    if (chart.data.datasets[i]) {
                         // Update data and core properties
                         Object.assign(chart.data.datasets[i], struct);
                    } else {
                         // Create new
                         chart.data.datasets.push({
                             ...datasetDefaults,
                             ...struct,
                             // Default visibility logic handled in applyBandVisibility
                             hidden: false
                         });
                    }
                });

                // Remove extra datasets if any (cleanup from old structure)
                if (chart.data.datasets.length > datasetsStruct.length) {
                    chart.data.datasets.splice(datasetsStruct.length, chart.data.datasets.length - datasetsStruct.length);
                }

                 applyBandVisibility(showBandsCheckbox.checked);

                chart.options.scales.x.min = extendedMinDay;
                chart.options.scales.x.max = extendedMaxDay;
                chart.options.scales.y.min = extendedMinPrice;
                chart.options.scales.y.max = extendedMaxPrice;
                chart.options.scales.x.afterBuildTicks = xAxisAfterBuildTicks;
                chart.options.scales.y.afterBuildTicks = yAxisAfterBuildTicks; 
                chart.update();

            } else {
                chart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        datasets: [
                            // 0: Boundary P1
                            { ...fillDatasetDefaults, label: 'Boundary P1', data: p1LineData, borderColor: 'transparent', fill: false },
                            // 1: Discount Band
                            { ...fillDatasetDefaults, label: 'Discount Band (P1-P20)', data: p20LineData, borderColor: 'transparent', backgroundColor: blueFillColor, fill: 0 },
                            // 2: Value Band
                            { ...fillDatasetDefaults, label: 'Value Band (P20-P50)', data: medianLineData, borderColor: 'transparent', backgroundColor: greenFillColor, fill: 1 },
                            // 3: Expensive Band
                            { ...fillDatasetDefaults, label: 'Expensive Band (P50-P80)', data: p80LineData, borderColor: 'transparent', backgroundColor: yellowFillColor, fill: 2 },
                            // 4: Bubble Band
                            { ...fillDatasetDefaults, label: 'Bubble Band (P80-P99)', data: p99LineData, borderColor: 'transparent', backgroundColor: redFillColor, fill: 3 },
                            
                            // 5: Price
                            { 
                                ...datasetDefaults, 
                                label: 'TAO Price', 
                                data: chartPriceDataPoints, 
                                backgroundColor: 'rgba(0, 0, 0, 0.05)', 
                                borderColor: 'rgba(0, 0, 0, 1)', 
                                borderWidth: 2, 
                                tension: 0.1, 
                                pointRadius: 0, 
                                pointHoverRadius: 0, 
                                pointHitRadius: 15 
                            },
                            // 6: Median (P50) - Initial style handled by applyBandVisibility
                            { ...datasetDefaults, label: '50th Percentile', data: medianLineData },
                            // 7: 1st
                            { ...datasetDefaults, label: '1st Pctl', data: p1LineData },
                            // 8: 99th
                            { ...datasetDefaults, label: '99th Pctl', data: p99LineData },
                            // 9: 20th
                            { ...datasetDefaults, label: '20th Pctl', data: p20LineData },
                            // 10: 80th
                            { ...datasetDefaults, label: '80th Pctl', data: p80LineData },
                        ]
                    },
                    options: {
                        responsive: true, maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                labels: {
                                    color: '#374151', usePointStyle: true, boxWidth: 30, boxHeight: 12,
                                    // Filter out the Band layers (0-4) and only show Price (5) and Lines (6-10)
                                    filter: (item) => item.datasetIndex >= 5
                                }
                            },
                            tooltip: {
                                callbacks: {
                                     title: (tooltipItems) => {
                                         if (tooltipItems.length > 0) {
                                             const item = tooltipItems[0];
                                             const dayNumber = item.parsed.x; 
                                             
                                             const { activeDayOffset } = activeModelParams;
                                             let targetDayIndex = dayNumber - activeDayOffset;
                                             
                                             let dataPoint = baseData.find(p => p.dayIndex === Math.round(targetDayIndex));
                                             
                                             if (!dataPoint) {
                                                 dataPoint = baseData.reduce((prev, curr) => {
                                                     return (Math.abs(curr.dayIndex - targetDayIndex) < Math.abs(prev.dayIndex - targetDayIndex) ? curr : prev);
                                                 });
                                             }

                                             if (dataPoint) {
                                                 const date = new Date(dataPoint.time);
                                                 return date.toLocaleDateString(undefined, { year: 'numeric', month: 'long', day: 'numeric' });
                                             }

                                             return `Day ~${targetDayIndex.toFixed(0)}`;
                                         }
                                         return '';
                                     },
                                    label: (context) => {
                                        // Hide tooltips for the transparent band layers
                                        if (context.datasetIndex < 5) return null;
                                        return `${context.dataset.label}: $${context.parsed.y.toFixed(2)}`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                type: 'logarithmic', min: extendedMinDay, max: extendedMaxDay,
                                title: { display: true, text: `Time (Log Scale)`, color: '#4b5563' },
                                ticks: { 
                                    color: '#4b5563', autoSkip: false,
                                    callback: function(value) {
                                        const tick = this.getTicks().find(t => t.value === value);
                                        return tick ? tick.label : null;
                                    }
                                },
                                afterBuildTicks: xAxisAfterBuildTicks, 
                                grid: { color: 'rgba(0, 0, 0, 0.1)' }
                            },
                            y: {
                                type: 'logarithmic', min: extendedMinPrice, max: extendedMaxPrice,
                                title: { display: true, text: 'Price (Log Scale)', color: '#4b5563' },
                                ticks: { 
                                    color: '#4b5563',
                                    callback: function(value, index, ticks) {
                                        const logVal = Math.log10(value);
                                        if (Math.abs(logVal - Math.round(logVal)) < 1e-9) {
                                            return `$${value.toLocaleString()}`;
                                        }
                                        return ''; 
                                    }
                                },
                                afterBuildTicks: yAxisAfterBuildTicks, 
                                grid: { 
                                    color: function(context) {
                                        const value = context.tick.value;
                                        if (value <= 0) return 'rgba(0, 0, 0, 0.1)'; 
                                        const logVal = Math.log10(value);
                                        if (Math.abs(logVal - Math.round(logVal)) < 1e-9) {
                                            return 'rgba(0, 0, 0, 0.1)'; 
                                        } else {
                                            return 'rgba(0, 0, 0, 0.05)';
                                        }
                                    }
                                }
                            }
                        }
                    }
                });
            }

            showBandsContainer.classList.remove('hidden');
            showBandsCheckbox.removeEventListener('change', handleBandToggle);
            showBandsCheckbox.addEventListener('change', handleBandToggle);

            useOptimalOffsetCheckbox.removeEventListener('change', createOrUpdateChart);
            useOptimalOffsetCheckbox.addEventListener('change', createOrUpdateChart);

            applyBandVisibility(showBandsCheckbox.checked);
            if(chart) chart.update('none'); 
        }

        function handleBandToggle() {
             if (!chart || !bandLevelsTable) return; 
             
             const showBands = showBandsCheckbox.checked;
             
             if (showBands) {
                 bandLevelsTable.style.display = ''; 
                 bandLevelsTable.classList.remove('hidden'); 
             } else {
                 bandLevelsTable.style.display = 'none'; 
             }

             applyBandVisibility(showBands);
             chart.update();
        }

        function calculateRSquared(data, slope, intercept) {
            let ss_tot = 0, ss_res = 0, y_mean = 0;
            const validData = data.filter(p => p.y > 0 && p.x > 0);
            if (validData.length < 2) return 0;

            validData.forEach(p => y_mean += Math.log10(p.y));
            y_mean /= validData.length;

            validData.forEach(p => {
                const logY = Math.log10(p.y);
                const logX = Math.log10(p.x);
                const predictedLogY = slope * logX + intercept;
                ss_tot += Math.pow(logY - y_mean, 2);
                ss_res += Math.pow(logY - predictedLogY, 2);
            });
             return ss_tot === 0 ? 1 : Math.max(0, 1 - (ss_res / ss_tot)); 
        }

        /**
         * Toggles visibility and styles for band datasets.
         * Enforces strictly different "views" based on the checkbox state.
         */
        function applyBandVisibility(showBands) {
             if (!chart || !chart.data || !chart.data.datasets || chart.data.datasets.length < 11) {
                 return;
             }
             
             // Helper to force visibility state
             const setVis = (index, visible) => {
                 chart.setDatasetVisibility(index, visible);
                 chart.data.datasets[index].hidden = !visible; 
             };

             if (showBands) {
                 // --- BANDS VIEW ---
                 // 1. Show fill layers (0-4)
                 for (let i = 0; i <= 4; i++) setVis(i, true);

                 // FORCE Price Visibility (5)
                 setVis(5, true);
                 
                 // 2. Enforce "Thin Solid Grey" style for ALL lines (6-10)
                 const fineGrey = grayFineLineStyle;
                 
                 // Median (6)
                 Object.assign(chart.data.datasets[6], fineGrey);
                 setVis(6, true);
                 // P1 (7)
                 Object.assign(chart.data.datasets[7], fineGrey);
                 setVis(7, true);
                 // P99 (8)
                 Object.assign(chart.data.datasets[8], fineGrey);
                 setVis(8, true);
                 // P20 (9)
                 Object.assign(chart.data.datasets[9], fineGrey);
                 setVis(9, true);
                 // P80 (10)
                 Object.assign(chart.data.datasets[10], fineGrey);
                 setVis(10, true);
                 
             } else {
                 // --- CLEAN VIEW ---
                 // 1. Hide fill layers (0-4)
                 for (let i = 0; i <= 4; i++) setVis(i, false);

                 // FORCE Price Visibility (5)
                 setVis(5, true);

                 // 2. Reset lines to default clean view styles
                 
                 // P50 (Median) -> Solid Orange, Visible
                 Object.assign(chart.data.datasets[6], orangeLineStyle);
                 setVis(6, true);
                 
                 // P1 (7) -> Dashed Grey, Visible
                 Object.assign(chart.data.datasets[7], grayDashedLineStyle);
                 setVis(7, true);
                 
                 // P99 (8) -> Dashed Grey, Visible
                 Object.assign(chart.data.datasets[8], grayDashedLineStyle);
                 setVis(8, true);
                 
                 // P20 (9) -> Hidden
                 Object.assign(chart.data.datasets[9], grayDashedLineStyle);
                 setVis(9, false);
                 
                 // P80 (10) -> Hidden
                 Object.assign(chart.data.datasets[10], grayDashedLineStyle);
                 setVis(10, false);
             }
        }

        /**
         * Calculates R-squared (coefficient of determination) for the log-log regression.
         */
        function calculateProjections(baseData, modelParams, dataElement) {
            const tableElement = document.getElementById('projectionTable');
            
            if (!baseData || baseData.length === 0 || !modelParams) {
                if(tableElement) tableElement.classList.add('hidden');
                return;
            }

            const { slope, meanIntercept, activeDayOffset } = modelParams;
            const firstDataPointDate = new Date(baseData[0].time);
            const firstDayIndex = baseData[0].dayIndex; 
            
            const today = new Date();
            const currentYear = today.getFullYear();
            const targetDates = [
                { label: "Today", date: today },
                { label: `${currentYear + 1}`, date: new Date(currentYear + 1, 0, 1) },
                { label: `${currentYear + 2}`, date: new Date(currentYear + 2, 0, 1) },
                { label: `${currentYear + 3}`, date: new Date(currentYear + 3, 0, 1) }
            ];
            const MS_PER_DAY = 1000 * 60 * 60 * 24;
            const getDayIndex = (targetDate) => {
                const diffTime = targetDate.getTime() - firstDataPointDate.getTime();
                const diffDays = Math.round(diffTime / MS_PER_DAY);
                return firstDayIndex + diffDays;
            };

            const calculatePrice = (targetDayIndex) => {
                let dayForLog = targetDayIndex + activeDayOffset;
                if (dayForLog <= 0) return NaN; 
                const logX = Math.log10(dayForLog);
                return Math.pow(10, slope * logX + meanIntercept);
            };

            let rowsHtml = '';
            targetDates.forEach(item => {
                const targetDayIndex = getDayIndex(item.date); 
                const projectedPrice = calculatePrice(targetDayIndex);
                const priceString = isNaN(projectedPrice) ? "N/A" : `$${projectedPrice.toFixed(2)}`;
                rowsHtml += `
                    <div>
                        <span>${item.label}</span>
                        <span>${priceString}</span>
                    </div>
                `;
            });

            if (dataElement) dataElement.innerHTML = rowsHtml;
            if (tableElement) {
                tableElement.style.display = ''; 
                tableElement.classList.remove('hidden');
            }
        }

        /**
         * NEW: Helper to make elements draggable via their header.
         * Supports Mouse and Touch events.
         */
        function makeDraggable(element, handle) {
            if (!element || !handle) return;

            let isDragging = false;
            let startX, startY, initialLeft, initialTop;

            const startDrag = (e) => {
                // Prevent default behavior to stop text selection, etc.
                if (e.type === 'touchstart') {
                     // e.preventDefault(); // Optional: usually better not to preventDefault on touchstart immediately
                } else {
                     e.preventDefault();
                }
                
                isDragging = true;
                
                // Get start position (mouse or touch)
                const clientX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
                const clientY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;

                startX = clientX;
                startY = clientY;
                
                // Get current element position
                const rect = element.getBoundingClientRect();
                
                // We use offsetLeft/Top relative to the parent container
                initialLeft = element.offsetLeft;
                initialTop = element.offsetTop;

                handle.style.cursor = 'grabbing';
            };

            const drag = (e) => {
                if (!isDragging) return;
                e.preventDefault();

                const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
                const clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;

                const dx = clientX - startX;
                const dy = clientY - startY;

                element.style.left = `${initialLeft + dx}px`;
                element.style.top = `${initialTop + dy}px`;
            };

            const stopDrag = () => {
                isDragging = false;
                handle.style.cursor = 'move';
            };

            // Attach events to handle
            handle.addEventListener('mousedown', startDrag);
            handle.addEventListener('touchstart', startDrag, { passive: false });

            // Attach events to document/window to track movement outside the handle
            document.addEventListener('mousemove', drag);
            document.addEventListener('touchmove', drag, { passive: false });
            
            document.addEventListener('mouseup', stopDrag);
            document.addEventListener('touchend', stopDrag);
        }


        // --- SECTION: CHART INTERACTIVITY (PAN & ZOOM) ---

        function toggleFullScreen() {
            if (!document.fullscreenElement && !document.webkitFullscreenElement) {
                if (mainContainer.requestFullscreen) mainContainer.requestFullscreen().catch(err => console.error(`Error entering fullscreen: ${err.message}`));
                else if (mainContainer.webkitRequestFullscreen) mainContainer.webkitRequestFullscreen();
            } else {
                if (document.exitFullscreen) document.exitFullscreen().catch(err => console.error(`Error exiting fullscreen: ${err.message}`));
                else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
            }
        }

        function handleFullscreenChange() {
             requestAnimationFrame(() => { 
                const isInFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement);
                const isMobile = window.innerWidth < 1024;
                const isLandscape = screen.orientation ? screen.orientation.type.includes('landscape') : window.innerWidth > window.innerHeight;

                if (isInFullscreen) {
                    fsIconEnter.classList.add('hidden');
                    fsIconExit.classList.remove('hidden');
                    fullscreenBtn.setAttribute('title', 'Exit Fullscreen');
                } else {
                    fsIconEnter.classList.remove('hidden');
                    fsIconExit.classList.add('hidden');
                    fullscreenBtn.setAttribute('title', 'Enter Fullscreen');
                }

                if (isInFullscreen && isMobile && isLandscape) {
                   mainContainer.classList.add('mobile-fullscreen-landscape');
                } else {
                   mainContainer.classList.remove('mobile-fullscreen-landscape');
                }

                 if (chart) {
                     setTimeout(() => {
                         requestAnimationFrame(() => {
                             if (chart) chart.resize();
                         });
                     }, 50); 
                 }
             });
        }

        function refitYAxis() {
            if (!chart || !priceData || priceData.length === 0) return;

            const currentXMin = chart.options.scales.x.min;
            const currentXMax = chart.options.scales.x.max;

            const visibleData = priceData.filter(p => p.x >= currentXMin && p.x <= currentXMax);

            if (visibleData.length < 2) {
                return; 
            }

            const prices = visibleData.map(p => p.y);
            const minPrice = Math.min(...prices);
            const maxPrice = Math.max(...prices);

            const logMinPrice = Math.log10(minPrice);
            const logMaxPrice = Math.log10(maxPrice);
            const logPriceRange = logMaxPrice - logMinPrice;

            let extendedMinPrice, extendedMaxPrice;
            
            const currentLogRangeX = Math.log10(currentXMax) - Math.log10(currentXMin);
            const originalLogRangeX = Math.log10(originalExtendedMaxDay) - Math.log10(originalExtendedMinDay);
            let zoomRatio = 1.0; 
            if (originalLogRangeX > 0) {
                 zoomRatio = currentLogRangeX / originalLogRangeX;
                 if (zoomRatio > 1.0) zoomRatio = 1.0;
                 if (zoomRatio < 0.0) zoomRatio = 0.0;
            }
            
            const minTopPadding = Y_AXIS_TOP_PADDING_MIN;
            const maxTopPadding = Y_AXIS_TOP_PADDING_MAX;
            const dynamicTopPadding = minTopPadding + (maxTopPadding - minTopPadding) * zoomRatio;
            const bottomPadding = Y_AXIS_BOTTOM_PADDING;
            
            if (logPriceRange > 0) {
                 extendedMinPrice = Math.pow(10, logMinPrice - logPriceRange * bottomPadding);
                 extendedMaxPrice = Math.pow(10, logMaxPrice + logPriceRange * dynamicTopPadding);
            } else {
                 extendedMinPrice = minPrice * 0.9;
                 extendedMaxPrice = maxPrice * 1.1;
            }

            chart.options.scales.y.min = extendedMinPrice;
            chart.options.scales.y.max = extendedMaxPrice;
        }

        function handleWheelZoom(event) {
            if (!chart || !priceData || priceData.length === 0) return;
            event.preventDefault(); 

            const chartArea = chart.chartArea;
            if (!chartArea) return;

            const rect = event.target.getBoundingClientRect();
            let cursorX = event.clientX - rect.left;
            
            if (cursorX < chartArea.left) cursorX = chartArea.left;
            if (cursorX > chartArea.right) cursorX = chartArea.right;

            const currentMinLog = Math.log10(chart.options.scales.x.min);
            const currentMaxLog = Math.log10(chart.options.scales.x.max);
            const currentLogRange = currentMaxLog - currentMinLog;
            
            const cursorPct = (chartArea.right - chartArea.left > 0) ? (cursorX - chartArea.left) / (chartArea.right - chartArea.left) : 0;
            const logAtCursor = currentMinLog + (currentLogRange * cursorPct);

            const zoomDirection = event.deltaY < 0 ? (1 - ZOOM_FACTOR) : (1 + ZOOM_FACTOR);
            let newLogRange = currentLogRange * zoomDirection;

            const minLogRange = 0.1; 
            const maxLogRange = Math.log10(originalExtendedMaxDay) - Math.log10(originalExtendedMinDay);
            
            if (newLogRange < minLogRange) newLogRange = minLogRange;
            if (maxLogRange > minLogRange && newLogRange > maxLogRange) newLogRange = maxLogRange;

            let newLogMin = logAtCursor - (newLogRange * cursorPct);
            let newLogMax = newLogMin + newLogRange;
            
            const originalMinLog = Math.log10(originalExtendedMinDay);
            const originalMaxLog = Math.log10(originalExtendedMaxDay);

            if (newLogMin < originalMinLog) {
                newLogMin = originalMinLog;
                newLogMax = newLogMin + newLogRange;
            }
            if (newLogMax > originalMaxLog) {
                newLogMax = originalMaxLog;
                newLogMin = newLogMax - newLogRange;
            }
            if (newLogMin < originalMinLog) newLogMin = originalMinLog;

            chart.options.scales.x.min = Math.pow(10, newLogMin);
            chart.options.scales.x.max = Math.pow(10, newLogMax);

            refitYAxis();
            chart.update('none');
        }

        // Mouse Pan Logic
        function handlePanStart(event) {
            if (!chart) return;
            isPanning = true;
            panStartX = event.clientX;
            panStartMin = chart.options.scales.x.min;
            panStartLogRange = Math.log10(chart.options.scales.x.max) - Math.log10(panStartMin);
            event.target.style.cursor = 'grabbing'
        }

        function handlePanMove(event) {
            if (!chart || !isPanning) return;

            const chartArea = chart.chartArea;
            if (!chartArea) return;

            const currentMinLog = Math.log10(chart.options.scales.x.min);
            const currentMaxLog = Math.log10(chart.options.scales.x.max);
            const logRange = currentMaxLog - currentMinLog;
            const pixelRange = chartArea.right - chartArea.left;
            if (pixelRange <= 0) return;
            const logPerPixel = logRange / pixelRange;

            const deltaX = event.clientX - panStartX;
            const logDelta = deltaX * logPerPixel;

            let newLogMin = Math.log10(panStartMin) - logDelta;
            let newLogMax = newLogMin + panStartLogRange;
            
            if (Math.pow(10, newLogMin) < originalExtendedMinDay) {
                newLogMin = Math.log10(originalExtendedMinDay);
                newLogMax = newLogMin + panStartLogRange;
            }
            if (Math.pow(10, newLogMax) > originalExtendedMaxDay) {
                newLogMax = Math.log10(originalExtendedMaxDay);
                newLogMin = newLogMax - panStartLogRange;
            }
            
            chart.options.scales.x.min = Math.pow(10, newLogMin);
            chart.options.scales.x.max = Math.pow(10, newLogMax);

            refitYAxis();
            chart.update('none');
        }

        function handlePanEnd(event) {
            if (!chart) return;
            isPanning = false;
            event.target.style.cursor = 'default';
        }

        // --- NEW: TOUCH EVENT HANDLERS FOR MOBILE (Pan & Zoom) ---
        let lastTouchX = 0;
        let lastTouchY = 0;
        let isTouching = false;
        let touchStartMin = 0;
        let touchStartLogRange = 0;

        function handleTouchStart(e) {
            if (!chart) return;
            // Only handle single touch to avoid conflicts if user accidentally taps with 2 fingers
            if (e.touches.length !== 1) return;
            
            // Prevent default behavior (scrolling the page)
            e.preventDefault();

            isTouching = true;
            lastTouchX = e.touches[0].clientX;
            lastTouchY = e.touches[0].clientY;
            
            // Snapshot current chart state for panning reference
            touchStartMin = chart.options.scales.x.min;
            const max = chart.options.scales.x.max;
            touchStartLogRange = Math.log10(max) - Math.log10(touchStartMin);
        }

        function handleTouchMove(e) {
            if (!chart || !isTouching || e.touches.length !== 1) return;
            e.preventDefault(); // Stop page scroll

            const currentX = e.touches[0].clientX;
            const currentY = e.touches[0].clientY;
            
            const deltaX = currentX - lastTouchX;
            const deltaY = currentY - lastTouchY;

            // 1. PANNING LOGIC (Left/Right)
            // We apply panning based on X movement
            const chartArea = chart.chartArea;
            if (chartArea) {
                const currentMinLog = Math.log10(chart.options.scales.x.min);
                const currentMaxLog = Math.log10(chart.options.scales.x.max);
                const logRange = currentMaxLog - currentMinLog;
                const pixelRange = chartArea.right - chartArea.left;
                
                if (pixelRange > 0) {
                    const logPerPixel = logRange / pixelRange;
                    const logDelta = deltaX * logPerPixel;

                    let newLogMin = currentMinLog - logDelta;
                    let newLogMax = newLogMin + logRange;

                    // Boundary checks
                    const originalMinLog = Math.log10(originalExtendedMinDay);
                    const originalMaxLog = Math.log10(originalExtendedMaxDay);

                    if (newLogMin < originalMinLog) {
                        newLogMin = originalMinLog;
                        newLogMax = newLogMin + logRange;
                    }
                    if (newLogMax > originalMaxLog) {
                         newLogMax = originalMaxLog;
                         newLogMin = newLogMax - logRange;
                    }
                    
                    chart.options.scales.x.min = Math.pow(10, newLogMin);
                    chart.options.scales.x.max = Math.pow(10, newLogMax);
                }
            }

            // 2. ZOOMING LOGIC (Up/Down)
            // Sliding UP (negative Y delta) zooms IN. Sliding DOWN (positive Y delta) zooms OUT.
            // Sensitivity constant - smaller means smoother/slower zoom
            const ZOOM_SENSITIVITY = 0.006; 
            
            // Determine zoom factor based on vertical movement
            // deltaY < 0 (Up) => Factor < 1 (Shrink range/Zoom In)
            // deltaY > 0 (Down) => Factor > 1 (Expand range/Zoom Out)
            const zoomFactor = 1 + (deltaY * ZOOM_SENSITIVITY);

            const currentMinLog = Math.log10(chart.options.scales.x.min);
            const currentMaxLog = Math.log10(chart.options.scales.x.max);
            const currentLogRange = currentMaxLog - currentMinLog;
            
            // Calculate new range
            let newLogRange = currentLogRange * zoomFactor;

            // Enforce Min/Max zoom levels
            const minLogRange = 0.1; 
            const maxLogRange = Math.log10(originalExtendedMaxDay) - Math.log10(originalExtendedMinDay);

            if (newLogRange < minLogRange) newLogRange = minLogRange;
            if (newLogRange > maxLogRange) newLogRange = maxLogRange;

            // Apply zoom centered on the current view
            const centerLog = (currentMinLog + currentMaxLog) / 2;
            let newLogMinZoom = centerLog - (newLogRange / 2);
            let newLogMaxZoom = centerLog + (newLogRange / 2);

            // Boundary checks for zoom
            const originalMinLog = Math.log10(originalExtendedMinDay);
            const originalMaxLog = Math.log10(originalExtendedMaxDay);

            if (newLogMinZoom < originalMinLog) {
                newLogMinZoom = originalMinLog;
                newLogMaxZoom = newLogMinZoom + newLogRange;
            }
            if (newLogMaxZoom > originalMaxLog) {
                newLogMaxZoom = originalMaxLog;
                newLogMinZoom = newLogMaxZoom - newLogRange;
            }
            
            // Apply Zoom results
            chart.options.scales.x.min = Math.pow(10, newLogMinZoom);
            chart.options.scales.x.max = Math.pow(10, newLogMaxZoom);

            // Update references for next frame
            lastTouchX = currentX;
            lastTouchY = currentY;

            // Redraw
            refitYAxis();
            chart.update('none');
        }

        function handleTouchEnd(e) {
             isTouching = false;
        }

    // --- SECTION: EVENT LISTENERS ---

        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange); 
        window.addEventListener('resize', handleFullscreenChange);
         if (screen.orientation) {
             screen.orientation.addEventListener('change', handleFullscreenChange);
         } else {
             window.addEventListener('orientationchange', handleFullscreenChange); 
         }

        // Initial load
        window.onload = () => {
            createOrUpdateChart();
            
            // Enable Dragging
            makeDraggable(document.getElementById('projectionTable'), document.getElementById('projectionHeader'));
            makeDraggable(document.getElementById('bandLevelsTable'), document.getElementById('bandsHeader'));
            
            useOptimalOffsetCheckbox.addEventListener('change', createOrUpdateChart);
            
            const canvas = document.getElementById('powerLawChart');
            if (canvas) {
                // Mouse Events
                canvas.addEventListener('wheel', handleWheelZoom, { passive: false });
                canvas.addEventListener('mousedown', handlePanStart);
                canvas.addEventListener('mousemove', handlePanMove);
                canvas.addEventListener('mouseup', handlePanEnd);
                canvas.addEventListener('mouseleave', handlePanEnd);
                
                // Touch Events (Mobile)
                canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
                canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
                canvas.addEventListener('touchend', handleTouchEnd);
                canvas.addEventListener('touchcancel', handleTouchEnd);

                canvas.style.cursor = 'default'; 
                
                canvas.addEventListener('mouseenter', (e) => {
                    e.target.style.cursor = isPanning ? 'grabbing' : 'default';
                });
            }

            setTimeout(handleFullscreenChange, 150); 
        }
    </script>
</body>
</html>
